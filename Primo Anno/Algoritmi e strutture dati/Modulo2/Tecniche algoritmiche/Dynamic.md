---
tags: 
aliases:
  - programmazione dinamica
  - algoritmo dinamico
  - Sottovettore di valore massimo
  - problema dello zaino
  - Seam Carving
  - Distanza di Levenshtein
data: "`2024-08-31 20:05`"
---
- ## Quando applicare:
	- ### Sotto-struttura ottima:
		- deve essere possibile combinare le soluzioni dei sotto-problemi per trovare la soluzione di un problema più grande
	- ### sotto-problemi ripetuti:
		- un sotto-problema compare più volte
- A differenza del [[Divide-et-impera]] usa tecniche iterative con approccio bottom-up.
- ## ES:
	- ### Calcolare la sequenza di Fibonacci.
		- utilizzare una soluzione che fa utilizzo di un [[Array]] 
		- ![[Fibonacci Dinamico.png]]
	- ### Sottovettore di valore massimo:
		- Considero un vettore $V[n]$ con $n$ valori reali 
		- voglio individuare un sottovettore non vuoto di V la somma dei cui elementi sia massima.
			- ![[Pasted image 20240820162246.png]]
		- #### Soluzione basata su programmazione dinamica:
			- Sia $P(i)$ il problema che consiste nel determinare il valore massimo degli elementi dei sottovettori non vuoti del vettore $V[i]$ che ha $V[i-1]$ come ultimo elemento.
			- Sia $S[i]$ il valore della soluzione di $P(i)$ 
				- $S[i]$ è la massima somma degli elementi dei sottovettori di $V[i]$ che hanno $V[i-1]$ come ultimo elemento.
			- la soluzione $S$ si può esprimere come:$$S=max_{0\leq i\leq n}S[i]$$
			- $P(1)$ ammette un'unica soluzione: $S[1]=V[1]$
			- Considero il problema in modo generico $P(i), \ i>1$
				- Suppongo di aver già risolto il problema $P(i-1)$ e quindi di conoscere $S[i-1]$ 
				- $$S[i-1]+V[i]\geq V[i]\implies S[i]=S[i-1]+V[i]$$
				-  $$S[i-1]+V[i]< V[i]\implies S[i]=V[i]$$
			- ![[Pasted image 20240820163443.png]]
				- Costo: $O(n)$ (Lineare)?
		- #### Individuare il sottovettore:
			- Devo determinare quale sottovettore produce la somma di valore massimo.
				- L'indice dell'elemento finale del sottovettore lo conosco
				- L'indice iniziale lo posso ricavare procedendo "a ritroso"
					- Se $S[i]=V[i]$ il sottovettoe massimo inizia nella posizione $i$
			- ![[Pasted image 20240820164238.png]]
	- ### Problema dello zaino:
		- Ho un insieme X di $n$ elementi; _l'oggetto i-esimo ha peso $p[i]$ e valore $v[i]$_; Ho un contenitore che può contenere un peso massimo _P_; _Voglio determinare un sottoinsieme $Y \subseteq X:$ il peso totale si $\leq$ P, il valore complessivo degli oggetti sia il massimo possibile_.
			- #### Scompongo Il problema
				- _Definiamo i sotto-problemi:_
					- lo zaino ha capienza "_j_" massimizziamo il valore dei primi "_i_" oggetti.
					- quindi $P(i, j)$
					- riducendo la quantità di oggetti e diminuendo anche la capacità dello zaino.
				- _Definiamo le soluzioni_
					- $V[i, j]$ è il massimo valore ottenibile da un sottoinsieme degli oggetti $\{1, 2, ..., i\}$ in uno zaino con capacità _"j"_
			- #### casi base:
				- ##### zaino capienza 0
					- $V[i, 0]=0\ \ \forall i=1...n$ 
				- ##### ho a disposizione solo l'oggetto 1:
					- $V[1, j]=v[1] \ \ \  se \ j\geq p[1]$ 
						- c'è spazio per l'oggetto 1
					- $V[1, j]= 0 \ \ \  se \ j< p[1]$ 
						- non c'è spazio per l'oggetto 1
			- #### caso generale:
				- ora procedo andando a guardare l'oggetto successivo, immaginando di aver già inserito gli oggetti precedenti.
				- _quindi avrò 2 scenari_:
					- non uso l'oggetto _i_, quindi avrò $V[i,j]=V[i-1,j]$
					- uso l'oggetto _i_, quindi avrò $v[i]+V[i-1, j-p[i]]$ sempre considerando la condizione: $p[i]\leq j$ 
				- infine guardo il massimo di quei due valori:
					- $$V[i,j]=max\{V[i-1,j], V[i-1,j-p[i]]+v[i]\}$$
		- ### Riassumendo:
			- $$\begin {cases}  V[i-1,j] &   \  j<p[i] \\ max\{V[i-1,j], V[i-1,j-p[i]]+v[i]\} &  \ j\geq p[i]\end {cases}$$
			- ![[Pasted image 20240820165855.png]]
			- ![[Pasted image 20240820165913.png]]
			- ![[Pasted image 20240820165930.png]]
			- _costo totale_ dell'algoritmo: $O(n*P)$ dove P è la capacità dello zaino.
	- ### Seam Carving
		- si intende ridimensionare un'immagine cercando di mantenere più soggetti dell'immagine possibile.
		- assegno ad ogni pixel (i, j) un peso $E[i, j] \in [0,1]$ che determina quanto è importante un pixel.
		- determino una cucitura verticale di peso minimo 
		- rimuovo i pixel di quella cucitura ottenendo un'immagine $M*(N-1)$
		- ripetiamo il procedimento fino ad ottenere la grandezza desiderata.
		- Definizione dei casi:
			- casi base: $W[1, j]=E[1,j]\ \forall j=1,...M$
			- caso generale (i > 1):
				- se j=1 -> $W[i,j]=E[i,j] +min\{ W[i-1,j], W[i-1,j+1]\}$
				- se 1 < j < N -> $W[i,j]=E[i,j] +min\{W[i-1,j-1], W[i-1,j], W[i-1,j+1]\}$
				- se j=N ->$W[i,j]=E[i,j] +min\{W[i-1,j-1], W[i-1,j]\}$
				  
		- ora che so che esiste una cucitura di val minimo devo trovare i pixel che la costituiscono, per farlo parto dall'ultimo pixel(ovvero quello con valore più basso) e poi vado a ritroso fino a quello della prima riga.
	- ### Distanza di Levenshtein
		- utilizzato nella correzione di errori di battitura o "misspelling"
		- basato sul concetto "edit distance"
			- ovvero numero di operazioni di editing servono per trasformare la parola scorretta in quella giusta.
			- editing ammessi:
				- lasciare un carattere uguale (costo: 0)
				- cancellare un carattere(costo: 1)
				- inserire un carattere (costo: 1)
				- sostituire un carattere (costo: 1)
			- ES:
				- trasformare albero in libero
				- ![[Distanza di levenshtein.png]]
		- Usare la programmazione dinamica per realizzare un algoritmo: 
			- #### Def:
				- Due stringhe $S[n]$ e $T[m]$ di _n_ e _m_ caratteri
				- La distanza di levenshtein tra $S$ e $T$ è il costo minimo tra tutte le sequenze di operazioni di editing che trasformano $S$ in $T$ 
			- #### Soluzione:
				- ##### Definisco i sotto-problemi $P(i,j)$:
					- Determinare il numero minimo di operazioni di editing necessarie per trasformare il prefisso $S[0..i]$ in $T[0..j]$ 
				- ##### Definisco le soluzioni $L[i,j]$:
					- minimo numero di operazioni di editing necessarie per trasformare il prefisso $S[0..i]$ in $T[0..j]$ 
				- ##### Calcolo della soluzione del problema originario.
					- La distanza di levenshtein tra $S[n]$ e $T[m]$ è il valore $L[n,m]$
				- ##### Calcolo di $L[i,j]$
					- $i=0 \ \vee \ j=0$
						- trasformare una stringa vuota in quella non vuota(occorre quindi inserire i caratteri necessari)
					- $i>0 \wedge \ j>0$, il minimo costo tra: 
						- trasformare $S[0..i-1]$ in $T[0..j]$ e _cancellare_ l'ultimo carattere $S[i]$
							- ![[Pasted image 20240820171523.png]]
							- _Costo_: $L[i-1,j]+1$
						- trasformare $S[0..i]$ in $T[1..j-1]$ e _inserire_ l'ultimo carattere $T[j]$
							- ![[Pasted image 20240820171615.png]]
							- _Costo_: $L[i,j-1]+1$
						- Trasformare $S[1..i-1]$ in $T[1..j-1]$ e _cambiare_ $S[i]$ in $T[i]$ _se diversi_.
							- ![[Pasted image 20240820171713.png]]
							- Costo: $L[i-1,j-1]$ e de sono diversi aggiungo 1
				- ##### Riassunto:
					- $i=0 \ \vee \ j=0$
						- $L[i,j]=max\{i,j\}$
					- altrimenti:
						- se $S[i]=T[j]$:
							- $$L[i,j]=min\{L[i-1,j]+1,L[i,j-1]+1,L[i-1,j-1]\}$$
						- se $S[i]\neq T[j]$
							- $$L[i,j]=min\{L[i-1,j]+1,L[i,j-1]+1,L[i-1,j-1]+1\}$$
			- ### ES:
				- ![[Pasted image 20240820172512.png]]