- è una collezione di insiemi $S=\{S_{1},...,S_k\}$ dinamici disgiunti
- Gli insiemi contengono n$\geq$ k elementi
- Ogni insieme ha un _rappresentante_ 
- Gli elementi di ogni insieme sono unici e appartengono ad un solo insieme.
- #### Operazioni
	- `void makeset(Data x)`:
		- crea un insieme il cui unico elemento (e rappresentante) è __x__ 
		- __x__ non deve appartenere a nessun altro insieme esistente 
	- `set find(Data x)`:
		- restituisce il rappresentante dell'unico insieme contenente __x__(un insieme).
	- `void union(Set x, Set y)`:
		- unisce i due insiemi __x__ e __y__
		- si assume che l'insieme risultato si chiami __x__
		- i vecchi insiemi vengono distrutti
- Per sapere se due dati sono "collegati" faccio l'uguaglianza tra find(x)e find(y) e se il risultato è lo stesso allora sono collegati.
- ## ES:
	- ![[Pasted image 20240806181700.png]]Tramite delle operazioni union effettuate tra le coppie il risultato finale risulta essere:
		- ![[Pasted image 20240806181754.png]]
		- insieme __x__ ha rappresentante _1_ e l'insieme __y__ ha rappresentante _9_ quindi  come detto in precedenza se dovessi confrontare `find(x)` e `find(y)` risulta che hanno risultato diverso perché appunto non sono collegati. ma se lo facessi tra _1_ e _5_ darebbero entrambi come risultato _1_ perché facenti parte dello stesso insieme con quel rappresentante
- ## Algoritmi 
	- ### QuickFind:
		- `makeset()`, `find()`: $O(1)$, `union()`:$O(n)$ 
	- ### QuickUnion:
		- `makeset()`, `union()`: $O(1)$, `find`:$O(n)$
- ## Rappresentazione
	- Ogni insieme è rappresentato con un albero di altezza 1 
	- le foglie contengono gli elementi dell'insieme 
	- la radice è il rappresentante
	- _N.B_: tra le foglie è presente anche il rappresentante
- ## QuickFind
	- ### Operazioni 
		- `makeset(x)`: crea un albero con unica foglia __x__ che ne è anche rappresentante; costo: costo: $O(1)$
		- `find(x)`:restituisce il puntatore al padre di __x__; costo: $O(1)$
		- `union(A, B)`: tutte le foglie di B vengono spostate in A costo pessimo: $O(n)$ __n__ è il numero complessivo di elementi di A e B 
			- nel caso peggiore B ha n-1 elementi (quindi con tanti puntatori da spostare in A) 
	- Esiste una strategia per diminuire il _costo_ dell'operazione `union()` in QuickFind ed è:
		- [[Euristica sul peso]]
- ## QuickUnion ^9be1ea
	- ### Implementazione basata su foresta
		- ogni insieme è un albero radicato generico
		- ogni nodo contiene:
			- _L'oggetto_ 
			- _Il puntatore al padre_ 
		- il rappresentante è la radice
	- ### Operazioni
		- `makeset(x)`:
			- crea albero con unico nodo __x__
			- costo: _costante_ anche nel caso pessimo
		- `find(x)`:
			- risale la lista dei padri di __x__ fino a trovare la radice e la restituisce come rappresentante 
			- costo: $O(n)$ nel caso pessimo
		- `union(A, B)`:
			- unisce l'albero B ad A rendendo la radice di B una figlia della radice di A
			- costo _costante_ anche nel caso pessimo
	- ### ES:
		- ![[Pasted image 20240806183242.png]]
	- il problema degli alberi QuickUnion è che possono diventare troppo alti e quindi rendere inefficienti le operazioni `find()` una soluzione è usare:
		- [[Euristica "union by rank"]] 
- #### Utilizzo 
	- Usare QuickFind quando le `union()` sono rare e le `find()` frequenti 
	- Usare QuickUnion quando le `find()` sono rare e le `union()` frequenti 
- ## Link utili
	- visualizzatore: https://www.cs.usfca.edu/~galles/visualization/DisjointSets.html 



