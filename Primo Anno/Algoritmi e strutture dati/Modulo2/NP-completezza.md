- Trattabilità:
	- se un problema ha una soluzione di costo polinomiale appartiene a questa categoria.
- ### Problemi computazionali
		- un problema Q è definito dalla relazione:
		- $Q\subseteq I\times S$
		- $I$ = istanze in ingresso
		- S = soluzioni
	- dato un input $x\in I$ e una soluzione $s\in S$ restituisce:
		- 1 se $(x,s)\in Q$
- ### Problemi di decisione:
	- le soluzioni sono booleane
	- ES:
		- dato un grafo dire se x è connesso
- ### Problemi di ricerca
	- data un istanza x restituire una sol s tale che $(x,s)\in Q$
	- ES:
		- trovare un albero di copertura per un grafo 
- ### Problemi di ottimizzazione:
	- Tra tutte le soluzione trovare quella ottima in base all'istanza x.
- con problemi decisionali riusciamo a caratterizzare dei lower bound per gli altri problemi.
  
  
  
- ### Complessità
	- chiamiamo $TIME(f(n))$ l'insieme dei problemi decisionali che possono essere risolti in tempo $O(f(n))$ dove n è l'input mentre $SPACE(f(n))$ riguarda lo spazio necessario per una soluzione
	- ## classe P:
		- problemi risolvibili in tempo polinomiale in n come istanza:
			- $P=\cup_{c=0}^{\infty}TIME(n^c)$
	- ## classe $PSPACE$:
		- problemi risolvibili in spazio polinomiale con n come istanza in ingresso
		- $PSPACE=\cup_{c=0}^{\infty}SPACE(n^c)$
	- ## classe $EXPTIME$:
		- in tempo esponenziale:
			- $EXPTIME=\cup_{c=0}^{\infty}TIME(2^{n^c})$
	- ## NOTA:
		- $P\subseteq PSPACE$ perché un algoritmo che impiega p tempo per eseguirsi accederà al massimo a $PSPACE$ spazi di memoria
		- poiché $n^c$ locazioni   possono trovarsi al massimo in $2^{n^c}$ stati diversi si ha che:
			- $PSPACE \subseteq EXPTIME$
			- nota: gli stati devono essere diversi perché altrimenti si entra in un ciclo e un algoritmo deve terminare.
			  
			  
- Verificare vs certificare
	- certificato:
		- indicazione di come istanziare le variabili per soddisfare una formula logica tramite farci vedere un certo oggetto y che garantisce che la formula da TRUE.
- # Classe NP:
	- è una classe di problemi decisionali che ammettono certificati, verificabili in tempo P.
		- dato $\forall x \exists C_{x}t.c\ D(C_{x})=1\Leftrightarrow(x,1)\in Q\implies  Q\in NP$ 
	- brute force per problemi NP 
		- genera tutti i problemi C e controllo se $D(C)=1$
		- ma di solito tutti i possibili certificati non sono polinomiali.
	- Definizione formale:
		- data una funzione chiamiamo $NTIME(f(n))$ l'insieme di problemi decisionali risolvibili da un algoritmo non deterministico in tempo $O(f(n))$ . La classe NP è la classe dei problemi risolvibili in tempo polinomiale non deterministico.
			- $NP=\cup_{c=0}^{\infty}NTIME(n^{c})$ 
- # Non determinismo
	- un algoritmo non deterministico "indovina" la soluzione $z\in S$ 
	- un parallelismo con altri algoritmi è quello [[Algoritmi Greedy||greedy]] dove si sceglie la soluzione determinata come migliore e potrebbe dare la risposta giusta e generare un certificato.
- # Albero di decisione
	- un algoritmo non deterministico può essere rappresentato con un albero di decisione, nell'esempio di una formula booleana se l'albero ha almeno una foglia =1 vuol dire che esiste un certificato che permette alla formula di essere risolta con TRUE. 
	- NOTA:
		- procedere tramite indovina non sempre funziona per quanto riguarda le formule con dei quantificatori universali come: $\forall$ 
- # Riducibilità polinomiale
	- cerco di capire se con due problemi uno lo è più dell'altro o sono uguali.
	- ES:
		- $Q_{1}\subseteq I_1\times\{0,1\}$ 
		- $Q_{2}\subseteq I_2\times\{0,1\}$
		- supponiamo di avere $f:I_{1}\rightarrow I_2$ in grado di trasformare in P tempo gli input di $Q_1$ in quelli di $Q_2$ tali che $\forall s$
			- $(x,s)\in Q_1\Leftrightarrow(f(x),s)\in Q_{2}$ 
- # NP arduo
	- Q è NP-hard se ogni problema $W\in NP$ è riducibile polinomialmente in Q 