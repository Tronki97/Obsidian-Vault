---
tags:
  - TODO
aliases: 
data: "`2025-04-02 12:55`"
---
- # Tipi base:
	- Sono valori denotabili semplici, possono essere chiamati `int, float, char` ed hanno una diversa definizione a differenza del linguaggio.
	- ## Tipo Unit:
		- Contiene una sola unità un singoletto, simile al tipo `void` che però non contiene nulla, quello che li accomuna è che rappresenta un ritorno che non influenza nulla in quanto ha una sola unità utile per eseguire una funzione del tipo: `f(g(5))` dove `f` richiede un qualcosa e `g` ritorna Unit che quindi non influenzerà il valore finale che però non si potrebbe fare se `g` ritornasse `void`.
	- ## Tipi booleani:
		- Comprendono i valori `true, false`
		- Hanno le operazioni logiche classiche.
	- ## Tipi carattere:
		- Insieme di codici di caratteri
		- Operazioni che dipendono dal linguaggio
		- Valori denotabili, esprimibili e memorizzabili.
		- La rappresentazione in memoria dipende dal modello hardware del linguaggio.
	- ## Tipi interi:
		- Come valori hanno un sottoinsieme finito di numeri interi fissato al momento della definizione del linguaggio
		- Operazioni aritmetiche
		- Valori denotabili, esprimibili e memorizzabili.
	- ## Tipi reali:
		- Come gli interi ma cambia la rappresentazione,
			- Virgola fissa o mobile, più ci si avvicina allo 0 più aumenta la precisione.
	- ## Enumerazione:
		- Insieme finito di costanti ciascuna con un proprio nome 
		- Serve per verificare che una variabile di tipo enumerazione assuma esattamente dei valori specifici che ritengo come corretti.
- # Tipi composti:
	- Insiemi di elementi denominati in modo particolare che sono composti da elementi dello stesso tipo base.
	- ## Tipi array:
		- Insieme di elementi dello stesso tipo, contigui in memoria, ognuno indicizzato da una chiave indicativa (come l’indice della posizione di un elemento).
		- Un altro tipo di array sono quelli associativi che al posto di usare delle chiavi di indice numerico usano delle chiavi di qualche altro tipo. 
			- Come le [[Tabelle Hash]] 
		- Inoltre si posso fare anche array multidimensionali con quindi più di una chiave di indice.
		- ### Operazioni:
			- Quella più semplice è quella di selezionare un elemento attraverso l’indice dell’array.
				- I linguaggi safe si assicurano che quando si accede ad uno o più elementi di quell’array non si esca dai confini delimitati dalla dimensione effettiva. 
			- Poi ci sono, in alcuni linguaggi, operazioni di assegnazione, confronto e aritmetiche che però necessitano che tutti gli array confrontati abbiano la stessa dimensione.
		- In alcuni linguaggi come [[Java]] gli array sono inizializzati a run-time e messi sull’ [[Heap]] vengono definiti _dinamici_ e hanno dimensione “variabile”.
		- ___Stride___: permette di fare i calcoli in base al rank degli array su cui va ad agire.
	- ## Tipi insieme:
		- Struttura dati senza ordine degli elementi ma devono essere unici. 
		- ### Operazioni:
			- I classici dell’algebra dell’insiemistica: inclusione, unione, intersezione, ecc…
			- Compreso anche il complementare di un insieme.
		- Può anche essere rappresentato con un _array caratteristico_
			- Dove il bit j-esimo indica se l’elemento j-esimo del tipo base appartiene all’insieme.
			- Scomodo da usare con grossi insiemi.
	- ## Tipi riferimento:
		- Da accesso indiretto ad un altro valore, ovvero _fa riferimento_ ad un dato.
		- ### Operazioni:
			- Creazione, uguaglianza, dereferenziazione ovvero avere accesso al dato referenziato rendendola "pratica".
		- ### Puntatori:
			- Fanno riferimento a dei dati in memoria.
			- Possono essere gli indici di array. 
			- Usati anche per implementare [[Alberi e Alberi binari]] e Liste. 
			- I riferimenti possono essere:
				- ### Wild:
					- Quando non sono inizializzati e possono causare comportamenti inaspettati.
				- ### Dangling:
					- Quando il dato referenziato viene deallocato e se ci si accede si potrebbe avere un comportamento inaspettato.
			- Nel `malloc` viene restituito un puntatore a `void` che normalmente non avrebbe senso in quanto è appunto vuoto, ma in realtà serve per dirmi che dopo quell’azione il controllo ritorna al programma che esegue il codice. Utile anche per evitare side-effect in quanto l’unica cosa che si lascia dietro (sullo heap) è il fatto di aver eseguito quella linea di codice.
			- Creo una variabile ed un puntatore dello stesso tipo e poi assegno al puntatore il valore della variabile usando `&` 
				- ![[Pasted image 20250409115835.png]]
			- La dereferenziazione:
				- ![[Pasted image 20250409115917.png]] 
				- Assegno al puntatore il valore contenuto nella variabile `pi` per poi andare a leggerlo e sommargli 1 per infine assegnarlo alla locazione di memoria puntata da `p`
			- Si può fare una _deallocazione implicita_ in quanto al posto di liberare ciò che viene puntato cambio invece ciò che esso punta mettendolo a `null`:
				- ![[Pasted image 20250409120348.png]]
	- 
- # Definire nuovi tipi:
	- ## Insiemi potenza:
		- $$\wp(S)=\{T:T\subseteq S\}$$
		- Rappresenta l’insieme potenza di $S$ che contiene tutti i sottoinsiemi generati da qualsiasi combinazione di elementi in $S$
			- ![[Pasted image 20250409124106.png]]
	- ## Coppie ordinate e prodotto cartesiano:
		- Siano $a\in A \ \ b\in B$ e $A\cap B = \emptyset$ e sia:
			- $$(a,b):=\{\{a\}, \{a,b\}\}$$
		- Allora:
			- $\{a\} ⊆ A \{b\} ⊆ B$
			- $\{a\} ∈ ℘(A), \ \ \{b\} ∈ ℘(B)$
			- $\{a, b\} ⊆ A ∪ B, \ \ \{a, b\} ∈ ℘(A ∪ B)$
			- $(a, b) ⊂ ℘(A ∪ B)$
			- $(a, b) ∈ ℘( ℘(A ∪ B) )$
			- Sia:
				- $$\{(a, b) | a ∈ A ∧ b ∈ B\} ≜ A × B$$
				- Chiamato quindi _prodotto cartesiano_
	- ## Tipi prodotto:
		- è un tipo composto, prendo per esempio un array e lo lego ad un tipo base ed ha operatori binari.
			- Quelli più comuni sono _coppie, tuple, record, varianti_.
		- La grandezza è fissata.
		- ## Coppie e tuple:
			- Dati due tipi $A,B$,
			- La forma più semplice del tipo prodotto e il tipo $A \times B$ rappresentano tutte le combinazioni dei valori in $A$ e $B$
			- Per farne l’accesso si vanno a controllare i vari elementi dentro a questo insieme.
		- ## record:
			- Non c’è una differenza posizionale negli elementi ma si danno dei nomi ad ogni elemento (come le [[Strutture]] in C).
		- ## Pattern matching:
			- Serve destrutturare certi tipi strutturati creati da tipi prodotto. Il _pattern matching_ controlla e individua elementi specifici rispetto ad un certo schema 
		- ## Tipi Ricorsivi:
			- Si impone una struttura di codice che può chiamare se stessa per definire il tipo ricorsivo usando i _Tipi prodotto_ _record:
				- ![[Pasted image 20250410133109.png]]
			- 
	- ## Tipi somma:
		- Serve poter indicare una variabile che può contenere un unione disgiunta di tipi, che dice che può contenere uno dei due tipi e non entrambi.
			- ![[Pasted image 20250409132807.png]]
		- Multiset:
			- Più elementi con lo stesso valore ma sono delle copie l’uno dell’altro.
			- Lo si potrebbe usare per i _problemi di statistica_????
		- Si fa usando delle unioni etichettate:
			- Ogni elemento si porta dietro il tipo a cui appartiene.
	- ## Relazioni:
		- Una relazione $\mathbb{R}\subseteq S_{1} \times...\times S_{n}$ è su un prodotto $S_{1} \times...\times S_{n}$ quando relaziona insieme gli elementi di quegli insiemi $S_{k}$ e ovvero è un sottoinsieme di tutte le possibili combinazioni delle tuple ottenibili con il prodotto cartesiano tra quegli insiemi.
		- ### Binaria:
			- $s$ source ; $t$ target
			- Quando $\mathbb{R} \subseteq S \times T$. Dati $s\in S, \ t\in T$ se $(s,t)\in \mathbb{R}$ allora si scrive $s \mathbb{R} t$
			- $S$ è il dominio di $\mathbb{R}$ e $T$ è l’immagine
	- ## Funzioni:
		- Una funzione si definisce come una relazione con un rapporto uno ad uno tra gli elementi di $S$ e $T$
		- Di solito si adotta la notazione: $$\mathbb{R}(s)=t$$
			- $s$ è l’_argomento_
			- $t$ è il _valore_ di $\mathbb{R}$ per $s$ 
		- Quando $S$ rappresenta tutto il dominio di $\mathbb{R}$ allora essa è una _funzione totale_
- # Algebra dei tipi:
	- Utilizzabile per esprimere e verificare le proprietà dei programmi. 
		- ![[Pasted image 20250410142548.png]]
- # metodi di computazione sui tipi:
	- ## Regole di equivalenza:
		- Controllo se due tipi corrispondono allo stesso tipo.
	- ## Regole di compatibilità:
		- Specificano quando un tipo può essere usato al posto di un altro.
	- ## Regole di inferenza:
		- Permette di abbassare il peso riguardo il manifest typing togliendo quindi delle annotazioni di tipo al programma.
	- 
- # Link Utili:
	- 