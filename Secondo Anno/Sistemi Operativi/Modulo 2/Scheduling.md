---
tags:
  - TODO
aliases: 
data: "`2025-03-06 15:20`"
---
- # Intro:
	- Manifestazione fisica di un [[Concorrenza#^68dcd8|processo]]:
		- Il codice da eseguire,
		- I dati su cui operare, 
		- Lo stack di lavoro per la gestione delle chiamate di funzione, passaggio di parametri e variabili locali.
	- Infatti in memoria si carica il codice eseguibile, la parte _Data_   
	- Quindi serve un [[Process Control Block]] per avere delle info in più sul processo 
- # Tabella dei processi;
	- Contiene i PCB ad ognuno associato un processo.
	- ## Identificazione:
		- Ogni processo ha un nome per potersi riferire a lui come 
			- `PID` (process Identifier) o `process_id` 
			- Può essere un _indice della tabella_ ma ciò sarebbe un problema nel caso si debba mandare un messaggio al processo $3$ che però era stato terminato e poi un altro processo aveva ricevuto quell’id, recapitando il [[Message passing#^d2687a|messaggio]] al processo sbagliato.
			- Può essere un _numero progressivo_ che però necessita di una mappa per sapere a quale processo corrisponde.
		- L’identificatore serve anche per riferirsi anche a tutti i processi collegati ad uno in particolare. 
			- Come il padre o i figli.
		- Inoltre è utile anche l’id dell’utente che ha richiesto l’esecuzione del processo.
	- ## Stato:
		- Vengono copiati valori dei registri del processore, come il PC, lo stack pointer, lo stato dei flag, ecc.
	- ## Controllo:
		- Informazioni per la gestione del processo.
			- Come lo stato di esecuzione: _pronto, in esecuzione, terminato_
		- Un identificatore dell'evento per cui il processo è in attesa
		- Info per gli algoritmi di scheduling usati:
			- Come la priorità del processo, i puntatori per le code
		- Inoltre deve essere presente anche il motivo per cui un processo è in attesa.
		- _accounting_
			- Il tempo in cui il processo è stato in esecuzione
			- Tempo trascorso dalla sua ultima esecuzione.
			- Utili per verificare l’efficienza di un processo.
- # Scheduler:
	- Assegna la CPU di volta in volta ad un processo, decide quindi quale processo mandare in esecuzione, 
		- Quando viene richiesta una operazione di I/O, il processo quindi viene sospeso.
		- Successivamente viene scelto un altro processo nello stato _ready_
		- _interval timer si comporta come dispositivo I/O_
	- ## Schedule:
		- è la sequenza temporale di assegnazioni delle risorse da gestire ai Richiedenti
	- ## Scheduling:
		- è l'azione di calcolare uno schedule
	- ## Mode switching:
		- Cambio tra modalità utente e kernel causato da un interrupt o da una syscall 
	- ## Context switching:
		- Quando lo schedule decide di eseguire un altro processo, sottoponendo il sistema ad un _context switch_
		- Lo stato del processo attuale viene salvato nel PCB e viene caricato il PCB di un altro processo che si vuole eseguire 
	- ## Stato dei processi:
		- _running_
			- Il processo è in esecuzione entra in questo stato quando viene scelto dallo scheduler preso dalla _ready queue_.
		- _waiting_:
			- Non può procedere fino a quando non si verifica un certo evento, ed inoltre non può essere caricato da nessuno finche non finisce.
		- _ready_
			- Il processo è pronto ad essere eseguito ma il processore è impegnato in un’altra attività
			- La struttura dati usata per gestire i processi in questo stato è la _ready queue_
	- ## Scheduling Round-robin:
		- 
	- ## Scheduling a priorità:
		- Non tutti i processi sono uguali tra loro e quindi alcuni devono essere eseguiti prima di altri in quanto potrebbero causare problemi.
			- Ogni processo ha quindi una priorità associata.
				- Definita o dal sistema operativo come nel shortest job first
				- Definita esternamente dall’utente con una syscall per esempio.
		- Si implementa con una coda [[Code con Priorità||coda con priorità]] 
		- ## Priorità:
			- _Statica_: uguale durante tutta la vita del processo.
				- Può avvenire [[Proprietà di un programma#^054a32|starvation]]
			- _Dinamica_: varia durante l’esecuzione del processo, per esempio nel shortest job next. 
				- utile per esvitare starvation, usando una tecnica chiamata _aging_ che consiste nel:
					- Aumentare la priorità di un processo in attesa gradualmente.
					- Se un processo è in attesa da molto tempo, la sua priorità aumenta.
					- Continuando ad aumentare la priorità e lui a rimanere in attesa prima o poi raggiungerà la priorità massima e verrà eseguito.
	- ## Scheduling a classi di priorità:
		- Si creano diverse classi di priorità dove si raggruppano diversi processi per una qualche somiglianza tra loro.
		- La coda _ready_ quindi è divisa in varie sotto-code, una per ogni classe di priorità.
		- Si sceglie la sotto-coda con priorità più alta che non sia vuota.
	- ## Scheduling multilivello:
		- Ha delle classi di priorità ed ognuna di queste ha un algoritmo di scheduling diverso per esempio:
			- Per i processi server uso la priorità statica.
			- Per quelli utente interattivi uso il round-robin
			- Per i processi batch uso il shortest job next.
	- ## Scheduling real-time:
		- La correttezza dell’esecuzione dipende sia dalla correttezza del risultato che dal tempo in cui viene prodotto.
			- ### Hard real-time:
				- Se il risultato non viene prodotto entro un certo tempo può provocare dei danni quindi non supererà mai la sua deadline
			- ### Sosoft real-time:
				- ritardi occasionali sono tollerati.
		- ### Processi periodici:
			- Processi riattivati con una cadenza periodica.
		- ### processi aperiodici:
			- Processi scatenati da un evento casuale, tipo l’allarme antiincendio. 
		- ### Rate monotonic:
			- La priorità è assegnata _staticamente_ in base alla frequenza di attivazione del processo.
				- Ogni processo periodico deve completare entro il suo periodo.
				- Tutti i processi sono indipendenti
			- Ad ogni istante viene eseguito il processo con maggiore priorità.
		- ### Earliest deadline first:
			- La priorità dei processi è dinamica.
			- Ad ogni istante viene eseguito il processo con deadline più vicina.
			- Ed è appunto dinamica perché varia continuamente la priorità relativa di due processi. 
- # Link Utili:
	- 