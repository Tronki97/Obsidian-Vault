- ## Introduzione:
	- ==Divide==: il problema in sotto-problemi più semplici
	- ==Impera==: risolve i sotto-problemi ricorsivamente 
	- ==Combina==: unisce le soluzioni dei sotto-problemi per costruire la soluzione 
	- #### ES: sotto-vettore non vuoto di valore massimo
		- vettore $V[n]$ di n valori 
		- vogliamo individuare un sotto-vettore non vuoto di v la cui somma degli elementi sia massima.
			- Domanda: quanti sono i sotto-vettori  di v?
				- risposta: $\frac{n(n+1)}{2}\in O(n^2)$  
		- prima versione brute force:
			- ![[Screenshot 2024-04-10 at 11-36-55 Tecniche Algoritmiche - 13-DivideEtImpera.pdf.png]]
			-  l'algoritmo ricalcola ogni volta la sommatoria con quindi 3 cicli abbiamo un costo di $O(n^3)$
		- seconda versione:
			- ![[Screenshot 2024-04-10 at 11-42-42 Tecniche Algoritmiche - 13-DivideEtImpera.pdf.png]]
			- qui ci si ricorda il valore della sommatoria precedente togliendo effettivamente un ciclo annidato scendendo ad un costo di $O(n^2)$
		- Versione divide-et-impera
			- dividiamo il vettore in 2 parti separate dal pivot centrale
			- il sotto-vettore potrebbe trovarsi:
				- nella prima metà
				- nella seconda metà
				- a cavallo tra la prima e la seconda:
					- posso cercare un sotto-vettore che inizia nella prima metà e finisce sul pivot centrale 
					- ![[Screenshot 2024-04-10 at 11-51-42 Tecniche Algoritmiche - 13-DivideEtImpera.pdf.png]]
					- trovo i sotto-vettori massimi sia a destra che a sinistra del pivot poi si aggiunge il pivot ad entrambi e poi si fa il max tra la somma a sinistra quella a destra e quella con il pivot.
					- Costo: si usa l'equazione di ricorrenza. e il [[Analisi ammortizzata#^4f2267||metodo dell'iterazione]] con:  $$T(n)=\begin {cases} 1 &n=1 \\2T(n/2)+n  &n>1 \end {cases}$$    T(n)=$\Theta(n\ log\ n)$ 
		- ##### Ricapitolando:
			- brute force: costo $O(n^3)$
			- brute force migliorato: costo: $O(n^2)$
			- Divide-et-impera: costo: $O(n\ log\ n)$
	- In conclusione: 
		- applicare divide-et-impera quando i passi dividi e combina sono semplici 
	- EZ:
		- Ho un array ordinato lunghezza n; definire un algoritmo che cerchi un indice _i_ , se possibile, tale per cui $A[i]=i$ 
			- Sol: 
				- usare ricerca binaria m=n/2, 
				- se: $A[m]==m$ return m; 
				- else if: $A[m]>m$ cerco a sinistra 
				- else if: $A[m]<m$ cerco a destra 
				- tutto ciò fatto in maniera ricorsiva.
				- il costo computazionale risultante è $O(log\ n)$ 